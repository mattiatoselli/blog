<!DOCTYPE html>
<html lang="it">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>La sfida dei microservizi</title>

  <!-- Custom fonts for this theme -->
  <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">

  <!-- Theme CSS -->
  <link href="../css/freelancer.css" rel="stylesheet">

</head>

<body id="page-top">

  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg bg-secondary text-uppercase fixed-top" id="mainNav">
    <div class="container">
      <a class="navbar-brand js-scroll-trigger" href="../index.html">Home</a>
      <button class="navbar-toggler navbar-toggler-right text-uppercase font-weight-bold bg-primary text-white rounded" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        Menu
        <i class="fas fa-bars"></i>
      </button>
    </div>
  </nav>


  <!-- Portfolio Section -->
  <section class="page-section portfolio" id="portfolio" style="margin-top: 30px;">
    <div class="container">
        <div class="row justify-content-center">
              <div class="col-lg-8">
                <!-- Portfolio Modal - Text -->
                <h4>Applicazioni monolitiche: un annoso problema</h4>
                <hr>
                <p class="mb-5" style="text-align: justify;">
                  <strong>Rifacciamoci alla descrizione che da RedHat sul suo sito:</strong> <br>
                  <i>
                  I microservizi sono un approccio architetturale alla realizzazione di applicazioni.
                  Quello che distingue l'architettura basata su microservizi dagli approcci monolitici tradizionali
                  è la suddivisione dell'app nelle sue funzioni di base.
                  Ciascuna funzione, denominata servizio, può essere compilata e implementata in modo indipendente.
                  Pertanto, i singoli servizi possono funzionare, o meno, senza compromettere gli altri.
                  </i>
                  <br>
                  <br>
                  Facciamola semplice e vediamo un esempio: immaginiamoci di essere dei Project manager che lavorano
                  in una azienda software italiana. Una commessa da una corporation molto grossa, arrivataci circa all'inizio degli anni 90
                  ci chiede di creare un gestionale per loro.
                  Secondo quelli che erano i pattern di quegli anni, l'applicazione avrà una struttura <i>monolitica</i>. cosa significa?
                  Significa che avremmo messo su un server (o magari più di uno) LAMP (Linux, Apache, MySQL, PHP), e creato le nostre applicazioni dentro di essi, ad ogni richiesta di aggiornamento, si testava il tutto, si mandava in produzione il codice
                  aggiornato, e si procedeva così.
                  <br>
                  <br>

                  <strong>Quali sono i problemi di un approccio simile?</strong>
                  <br>
                  Tanti, anzi, troppi.
                  <i>
                    Il primo (che riguarda la vostra azienda) è che ogni sviluppo di nuove funzionalità vi
                    porterà via parecchio tempo.
                  </i>
                  Ogni rilascio in produzione dovrà essere infatti preceduto da un testing molto accurato, lungo, minuzioso e ben fatto.
                  Questo porta ai vostri sviluppatori uno stress notevole, e uno sviluppatore stressato non produce, o produce male.
                  Altro problema non indifferente: per il vostro progetto serviranno dei tester, degli ingegneri di Quality Assurance, e questo significa stipendi in più.
                  <i>Come glielo spiegate al vostro titolare quando verrà a dirvi che il vostro reparto pesa tantissimo sul budget dell'azienda e che si sta pensando di tagliarlo?</i>
                  <br>
                  <br>
                  <strong>
                    In tutto questo non abbiamo considerato nemmeno l'ipotesi più catastrofica:<br>
                  </strong>
                  cosa facciamo se nonostante tutti i test qualcosa dovesse "spaccare" l'ambiente di produzione?
                  ovviamente, bisogna spegnere i server, ritornare allo stato precedente, far ripartire le macchine, e ritardare ulteriormente
                  lo sviluppo. Possiamo permettercelo? Ovviamente no.
                </p>


              <h4>La soluzione: i microservizi</h4>
                <hr>
                <p class="mb-5" style="text-align: justify;">
                  <img src="../img/monolithic-vs-microservices.png" alt="microservices vs monolithic schema" class="img-fluid">
                  Pensa ad una applicazione per una azienda che abbia un e-commerce.
                  Probabilmente avrai una barra di ricerca per sfogliare i prodotti.
                  La ricerca costituisce un servizio. Potresti avere anche dei suggerimenti per i prodotti correlati,
                  che sono basati su un database di preferenze dei clienti.
                  Anche questo è un servizio. Carrello online con delle variabili di sessione che vengono salvate? Ovviamente è un altro servizio.
                  <i>
                    Pertanto, un microservizio è una funzione di base di un'applicazione, che viene eseguita indipendentemente
                  dagli altri servizi.
                  </i>
                  <br>
                  <br>
                  <strong>
                    Quali sono i vantaggi?
                  </strong>
                  <br>
                  Ve ne sono diversi, sia a lungo che a breve termine.
                  <br>
                  <br>
                  <strong>
                    1) E' possibile parallelizzare lo sviluppo di più funzionalità su diversi team, che avranno la possibilità
                    di doversi concentrare solo su un unico compito, quindi tanti piccoli team, ognuno specializzato, ognuno con un compito più piccolo.
                  </strong>
                  ciò significa completamento più rapido delle commesse, team specializzati, veloci ed efficienti.
                  <br>
                  <br>
                  <strong>
                    2) Ogni servizio è slegato dagli altri.
                </strong>
                    Significa che un temporaneo malfunzionamento della barra di ricerca del nostro e-commerce di esempio precedente, non manderà
                    in crash l'intero sistema, ma sarà temporaneamente inutilizzabile fino a quando il team che se ne occupa non lo avrà sistemato, ma il resto del nostro e-commerce
                    resterà in piedi.
                    <br>
                    <br>
                    <strong>
                      3) Scalabile, sviluppo agile.
                  </strong>
                      Ogni modifica sarà più veloce perchè si andranno a fare delle leggere modifiche solo al servizio corrispondente.
                      Lo sviluppo di nuove funzionalità sarà più immediato e rapido, inoltre in qualunque momento ognuno dei servizi potrà essere ottimizzato
                      o potranno essergli allocate più risorse. Il nostro e-commerce cresce molto e ha bisogno di aumentare le risorse perchè i server che si occupano
                      di immagazzinare le preferenze degli utenti sono sovraccaricati? In qualunque momento possiamo decidere di aumentarne la potenza destinata solo a quel singolo servizio.
                </p>

                <h4>Container Linux e Docker: sicuri, veloci, semplici</h4>
                <hr>
                <p class="mb-5" style="text-align: justify;">
                  Immagina di sviluppare un'applicazione. Lavori su un portatile e il tuo ambiente presenta una configurazione specifica.
                  Altri sviluppatori potrebbero utilizzare configurazioni leggermente diverse.
                  L'applicazione che stai sviluppando dipende da tale configurazione, oltre che da specifiche librerie, dipendenze e file.
                  Al tempo stesso, gli ambienti di sviluppo e produzione della tua azienda presentano
                  le proprie configurazioni standardizzate con set di file di supporto specifici. Desideri emulare tali
                  ambienti il più possibile localmente, ma senza tutti i costi derivanti dalla creazione di nuovi ambienti server.
                  A questo punto, è necessario trovare un modo semplice per far funzionare la tua app in questi ambienti,
                  superare i controlli qualità e ottenere il deployment,
                  senza dover riscrivere l'applicazione e correggere errori. In questo caso, i container sono la soluzione ideale.
                  <br>
                  <br>
                  <strong>
                    Il container che ospita la tua applicazione presenta le librerie, le dipendenze e i file necessari,
                  il che ti consente di passare fino all'ambiente di produzione,
                  senza alcun impatto negativo. Infatti, il contenuto di un'immagine container può essere paragonato
                  all'installazione di una distribuzione Linux
                </strong>
                  poiché include pacchetti,
                  file di configurazione e così via. La distribuzione di un'immagine container è,
                  tuttavia, molto più semplice dell'installazione di nuove copie dei sistemi operativi (o di macchine virtuali).
                  I container consentono di prevenire problemi.
                  <br>
                  <br>
                  C'è di più: Rispetto alle macchine virtuali, un container Linux in esecuzione utilizza le risorse in modo meno intensivo,
                  nel primo caso infatti, una macchina virtuale prende delle risorse dal sistema di host per replicare l'hardware ed eseguire un sistema operativo parallelo.
                  Nel secondo, uno o più container condividono il kernel della macchina ospitante, ma lanciano una serie di processi e demoni completamente isolati dalla macchina ospitante.
                  Mi rendo conto che tutto questo possa sembrare un argomento complicato (e lo è), ma <strong>al netto della teoria, quali sono i vantaggi pratici?</strong>
                  <br>
                  <strong>
                    Anzitutto: un consumo minore di risorse e la portabilità, oltre alla semplicità con cui i container possono essere creati e distrutti.
                  </strong>
                  Creare, distruggere o modificare un container Linux è un processo facile e velocissimo, possiamo scegliere di rendere i cambiamenti
                  effettivi fatti su un container, oppure distruggerlo e ricreare un ambiente completamente nuovo, il tutto in
                  pochissimi secondi e con due comandi da terminale.
                  <br>
                  <strong>
                    Tutta la potenza e la sicurezza di Linux.
                  </strong>
                  <br>
                  <img src="../img/linux_power.jpg" alt="linux power" class="img-fluid">
                  <br>
                  I container sfruttano la potenza di Linux e la sua portabilità, possono esser fatti girare senza alcun problema su qualunque sistema operativo
                  (anche Mac O Windows), con performance uguali a quelle native della macchina ospitante.
                </p>

                <h4>Docker: la balena leggerissima</h4>
                <hr>
                <img src="../img/docky.jpeg" alt="docker balena con simbolo golang e linux" class="img-fluid">
                <p class="mb-5" style="text-align: justify;">
                  Docker è un progetto open source che permette di gestire container Linux, fonìrnisce delle API molto ad alto livello per
                  la loro gestione, il vantaggio è che è un software molto leggero scritto in golang, e che si integra perfettamente con tutti i servizi maggiori di cloud hosting mondiali.
                  <br>
                  <br>
                  <strong>
                    Questo ci porta alla conclusione della prima parte!
                  </strong>
                  Abbiamo visto quali sono i vantaggi di una architettura a microservizi, cosa sono i container Linux, i loro vantaggi, e introdotto nella scena un software per la loro gestione. Nei prossimi capitoli, vedremo come scaricare Docker su una macchina Linux,
                  e prenderemo dimistichezza coi primi comandi.
                </p>
              </div>
            </div>
            <hr>
            <a href="02_installare_docker.html" style="align-self: right;">
                <button class="btn btn-light" >
                 <img src="https://img.icons8.com/ultraviolet/40/000000/right-squared.png"><br>
                 <strong>Installare Docker</strong>
                </button>
                </a>

    </div>
  </section>

  <!-- Footer -->
  <footer class="footer text-center">
    <div class="container">
      <div class="row">

        <!-- Footer Location -->
        <div class="col-lg-4 mb-5 mb-lg-0">
          <h4 class="text-uppercase mb-4">Contattami</h4>
          <p class="lead mb-0">toselli.mattia@gmail.com</p>
        </div>

        <!-- Footer Social Icons -->
        <div class="col-lg-4 mb-5 mb-lg-0">
          <h4 class="text-uppercase mb-4">Seguimi</h4>
          <a class="btn btn-outline-light btn-social mx-1" href="#">
            <i class="fab fa-fw fa-facebook-f"></i>
          </a>
          <a class="btn btn-outline-light btn-social mx-1" href="#">
            <i class="fab fa-fw fa-twitter"></i>
          </a>
          <a class="btn btn-outline-light btn-social mx-1" href="#">
            <i class="fab fa-fw fa-linkedin-in"></i>
          </a>
          <a class="btn btn-outline-light btn-social mx-1" href="#">
            <i class="fab fa-fw fa-dribbble"></i>
          </a>
        </div>

        <!-- Footer About Text -->
        <div class="col-lg-4">
          <h4 class="text-uppercase mb-4">Risorse utili</h4>
          <p class="lead mb-0">Temi Bootstrap:
            <a href="http://startbootstrap.com">Start Bootstrap</a>.</p>
            <p class="lead mb-0">Guida ufficiale Laravel:
            <a href="https://laravel.com/docs/4.2/introduction">Laravel docs</a>.</p>
        </div>

      </div>
    </div>
  </footer>

  <!-- Copyright Section -->
  <section class="copyright py-4 text-center text-white">
    <div class="container">
      <small>Copyright &copy; HCT Solutions 2019. Tutti i diritti riservati.</small>
    </div>
  </section>

  <!-- Scroll to Top Button (Only visible on small and extra-small screen sizes) -->
  <div class="scroll-to-top d-lg-none position-fixed ">
    <a class="js-scroll-trigger d-block text-center text-white rounded" href="#page-top">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Contact Form JavaScript -->
  <script src="js/jqBootstrapValidation.js"></script>
  <script src="js/contact_me.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/freelancer.min.js"></script>

</body>

</html>
